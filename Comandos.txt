Curso
-----
https://courses.edx.org

Otro Curso Largbo de Youtube
-----------------------------
https://www.youtube.com/watch?v=9t_gJWC32zk


Libro gratis con todos los comandos
-----------------------------------
http://linuxcommand.org/tlcl.php


Guia de Re-instalacion Avanzada
-------------------------------
http://astr.tohoku.ac.jp/~akhlaghi/newlinux.html


Guia de Centos 5
----------------
https://www.centos.org/docs/5/

https://wiki.centos.org/Manuals/ReleaseNotes/CentOS6.0?highlight=%28%28Manuals%7CReleaseNotes%7CCentOS6.0%29%29


Red Hat 6.8
-----------
https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/6.8_release_notes/


Comandos
---------

0) Manual

  El manual que explica como leer los manuales se llama man y el comando para leer los manuales es man

  $ el signo pesos es lo que siempre esta a la izquierda del prompt

  $ man man   (Nos lleva al help del manual del linux)

  h dentro del manual nos desplega los shorcuts de navegacion.


  - Shorcuts Utiles

  j 		Avanza 1 Linea
  k 		Retrocede 1 linea
  Ctrl+f 	Avanza 1 Pagina
  Ctrl+b 	Retrocede 1 Pagina
  g 		Salta al Inicio
  G 		Salta al final

  man cat   (nos muestra el manual del cat)

  Parametros:

  Los parametros de los comandos se pueden usar de la siguiente manera:

  ls --width = 60
  ls -w 60
  le -w60

  - Algunos comandos largos tienen secciones
  Podemos leer esas secciones ejecutando:

  $ man 2 unlink	(Muestra la seccion 2 de unlink)

  Para listar las apariciones de una palabra o comando en otros manuales usar

  $ man -k comando o palabra

  - NOTA: Existen comandos que perteneces al shell y para estos comandos no hay man pero si help

  $ man bach

  	Ahi podemos ejecutar una busqueda y escribir   / SHELL BUILTIN COMMANDS

  - En comando Type, nos permite saber si el comando se trata de un builtin command del bash o de un ejecutable.

  $ help       (Nos da una lista de comandos donde podemos usar el help)
  $ help help  (Nos da algunos argumentos que podemos usar con el help)
  $ type help  (Responde -> help is a shell builtin)
  $ type while (Responde -> while is a shell keyword) Una especie de builtin command


  - Tambien existe el comando info que se cubre en el punto 54)


1) Permisos de ejecucion

	chmod +x filename.ext

2) Descomprimir archivos tar.gz

   tar xvzf file.tar.gz

3) Ver la version del desktop que estamos ejecutando (GNOME/KDE)

   printf 'Desktop: %s\nSession: %s\n' "$XDG_CURRENT_DESKTOP" "$GDMSESSION"


4) Secuencia de Arranque
	- Algunos pasos de bajo nivel
	- Bootloader (Con seleccion del OS de arranque)
	- /sbin/init  (El promer programa que se corre)

5) Metodos de carga de scrips en el arranque

	Startup Alternatives: 

	A) Upstart o System V (sistema viejo y presente hasta RHEL 6)

		Developed by Ubuntu and first included in 2006
		Adopted in Fedora 9 (in 2008) and in RHEL 6 and its clones.	

	B) systemd (nuevo sistema de carga en paralelo y mas rapido)

		Adopted by Fedora first (in 2011)
		Adopted by RHEL 7 and SUSE 
		Replaced Upstart in Ubuntu 16.04

6) Tipos de formatos

	Conventional disk filesystems: ext2, ext3, ext4, XFS, Btrfs, JFS, NTFS, etc.
	Flash storage filesystems: ubifs, JFFS2, YAFFS, etc.
	Database filesystems
	Special purpose filesystems: procfs, sysfs, tmpfs, debugfs, etc.	


 							Windows			Linux
 							-------         ---------
	Partition				Disk1			/dev/sda1
	Filesystem type			NTFS/VFAT		EXT3/EXT4/XFS/BTRFS...
	Mounting Parameters		DriveLetter		MountPoint
	Base Folder for OS 		C:\				/


7) Puntos de montaje

	/media
	/run/media (en los nuevos kernels)	

8) Script de instalacion automatizado 
	En Fedora (RHEL) se llama Kickstart

9) Interfaz grafica
	Para lanzarla desde la consola corremos el comando: startx	

	- gnome-tweak-tool  para customizar mas el desktop

	En consola tipear: yum install gnome-tweak-tool

10) Tomar el control en consola como root

	su

11) Cambio de consolas y modo grafico

	Ctrl + Alt + F1 (X11 Interfaz grafica)
	Ctrl + Alt + F2-F7  Consolas

12) Carpetas de los usuarios
	
	/home/usrName

13) Mostrar archivos ocultos y otros tips del explorador de archivos

	Podemos abrirlo desde consola tipeando: nautilus

    Ctrl + h hidden view
    Ctrl + 1 Icon view
    Ctrl + 2 List vire
    Ctrl + f Search
    Ctrl + l Location

14) Ubicacion de la papelera

	.local/share/Trash/files/

	.local refiere a un directorio oculto del home delusuario. 
	Tenemos que apretar Ctrl + h  para ver los archivos ocultos y ver el .local

15) Ubicacion de la data del Linux

	System -> About	this computer

16) Archivo de configuracion del X11

	/etc/X11/xorg.conf


17) Ubicacion de la instalacion de add-ons de las apps

	/etc/opt

18) Ubicacion de los comandos

	/bin  				Ejecutables por cualquier usuario
	/sbin 				Ejecutables para la administracion del sistema (root)  binarios para booteo, restore, recover, repair
	/usr/sbin  			Ejecutables para la administracion del sistema (root)
	/usr/local/sbin		Ejecutables para la administracion del sistema (root)

19) Installing and Updating Software  (Red Hat Package Manager - RPM)

	YUM -> RPM-Installer -> Fedora Family

	yum (Yellowdog Updater, Modified)

	PackageKit is the default interface in Fedora

	A) Arriba a la derecha System Preferences
	B) Add / Remove Software

	Tambien podemos ir a la izquierda a System -> Administration -> Add-Remove Software


20) Comandos

	a) cat    	muestra un archivo
		eg: cat /etc/resolv.conf
	b) head 	muestra el principio de un archivo
		eg: head -n 2 /etc/resolv.conf

	Comandos con Pipes 
	-------------------

	(Output del 1ro es el input del segundo y asi sucesivamente)

	Para tipear el simbol de pipe | usamos (shift + \)

	c) eg: man cat | head -n 20

	- muestra el manual de cat y se lo manda como entrada
	al comando head que a su vez tiene el parametro -n para mostrar las primeras 20 lineas

	d) tail 	muestra el final de un archivo

	e) grep		busca dentro de un archivo y permite expresiones regulares e infinidad de cosas

	Buscar dentro del las 10 primeras lineas de resolv.conf la palabra search

	eg: head /etc/resolv.conf | grep search   

21) sudo (Convertir el usuario en Super User) OPCION 1

	Se recomienda leer el punto 21.1) que usa el editor visudo


	a) Ir a la consola y fijarse el nombre del usuario  
	   Supongamos que el usuario es filmico  [filmico@localhost ~]$ 

    b) cambiamos al usuario root

       su

	c) Debemos crear un archivo de permisos para el usuario filmico. 
	   Para ello tipeamos:

		echo "filmico ALL=(ALL) ALL" > /etc/sudoers.d/filmico

	    Esto agrega lo que esta entre comillas al archivo filmico ubicado en /etc/sudoers.d

    d) Por ultimo, debemos cambiar los permisos del archivo creado

       chmod 440 /etc/sudoers.d/filmico

    e) Podemos verificar que el archivo esta ahi tipeando:

       cat /etc/sudoers.d/filmico

   Se explica mas en el punto 30)

21.1) sudo (Convertir el usuario en Super User) OPCION 2

	$ su               (Lo hacemos como root)

	$ visudo -f /etc/sudoers

	- Vamos a encontrar una linea que dice:

	## Allow root to run any commands anywhere
	root    ALL=(ALL)       ALL

	Esto indica que root puede acceder a Todas las maquinas y ejecutar todos los comandos como todos los usuarios

	Tambien existe el caso de permisos a usuarios de un grupo y se indican con un simbolo %

	## Allows people in group wheel to run all commands
	%wheel        ALL=(ALL)       ALL

	Si observamos, existe una directiva donde el simbolo # no funciona como comentario y permite agregar directivas de permisos desde un archivo. Este archivo se llama sudoers.d y se encuentra en /etc/  Esto es lo que se explico en el paso anterior 21)

	## Read drop-in files from /etc/sudoers.d (the # here does not mean a comment)
	#includedir /etc/sudoers.d

	- Supongamos que tenemos un grupo llamado admin. Para darle permisos de usar sudo a los admins escribiriamos.

	%admin ALL=(ALL) ALL

	- Ahora tenemos que agregar al usuario que querramos al grupo admin y lo convertimos en admin

	$ groupadd admin		               Creamos el grupo admin

	$ usermod -G "admin" filmico           Agregamos a filmico al grupo "admin"

	Reiniciar

	Fuente: https://www.techotopia.com/index.php/Managing_Fedora_Linux_Users_and_Groups


	Lo que sigue es un ejemplo largo pero vale la pena para entender mas de los permisos
	====================================================================================

	Vamos a ver el uso de los alias para los sudoers.

	- Supongamos que tenemos el siguiente archivo

	/etc/sudoers.d/student.tmp

	# Allow specific students to execute network applications
	Cmd_Alias	CAPTURE = /usr/sbin/tcpdump
	Cmd_Alias	NETWORK = /sbin/ifconfig, /sbin/ifdown
	Cmd_Alias	WLAN = /sbin/iwconfig, /sbin/iwevent
	Cmd_Alias	NETALL = CAPTURE, NETWORK, WLAN
	%netadmin ALL=NETALL

	- Todos los usuarios (ALL) en el grupo netadmin, obtienen los permisos del alias NETALL
	- A su vez, NETALL contiene los tres alias CAPTURE, NETWORK y WLAN que a su vez contiene
	  las rutas a los ejecutables permitidos y es lo que finalmente termina heredando el 
	  grupo %netadmin

	- Este archivo /etc/sudoers.d/student.tmp debe ser agregado como un include en /etc/sudoers

	#includedir /etc/sudoers.d/student.tmp


22) Apagar y encender GUI

	Apagar: 	sudo telinit 3       
	Encender: 	sudo telinit 5


23) Conectarse via ssh

	ssh username@remote-server.com

24) Apagar y Reiniciar OS

	shutdown -h now   (h de halt)	
	shutdown -r now   (h de reboot)	

	Para apagar dando aviso de apagado y poniendo un tiempo usar:

	sudo shutdown -h 10:00 "Shutting down for scheduled maintenance."

	Tambien podemos usar $ poweroff   y    $ halt

25) Ubicando Programas

	Dependiendo de la distro, los programas pueden estar en varias ubicaciones:

	/bin, /usr/bin, /sbin, /usr/sbin directories, or under /opt

	Supongamos que queremos saber donde esta el firefox:

	$ which firefox

	/usr/bin/firefox

	Si wich no funciona podemos usar whereis que hace una busqueda amplia incluyendo paquetes

	$ whereis firefox

26) Directorio Home y comando cd

	Por default, la distro Scientific abre la consola en el $HOME

	lo podemos verificar usando el comando ls o viendo que a la izquierda esta el simbolo ~

    echo $HOME   (Ubicacion del $HOME)
    cd ~ o cd    (cambia al directorio $HOME)
    pwd          (present working directory  /home/filmico)
    cd ..        (Sube al padre)
    cd -         (Vuelve al directorio anterior)


27) Permisos

	[filmico@localhost ~]$ ls -l
  
    Permisos    Links del Archivo    Owner    Group   Size Date         File/Directory
	drwxr-xr-x.       3              filmico  filmico 4096 Jun  2 15:53 Desktop

    Los permisos se indican con 10 caracteres (drwxr-xr-x.)

    a) El primero indica si es un directorio d o un archivo -
    b) Despues vienen 9 caracteres que se leen de a 3 juntos que indican

    primeros 3    -> permisos del usuario owner
    segundos 3    -> permisos del grupo
    ultimos  3    -> permisos de usuarios del sistema que no estan en el grupo ni son el owner

    d = directorio
    r = read
    w = write
    x = execute
    - = permission not set


    En terminos de directorios, la x (executable) permite entrar con cd
    r permite ver el contenido con ls
    w permite crear, modificar y borrar archivos en el directorio

    En terminos de archivos, permiso de escritura es permiso de borrado tambien.


28) Listar grupos

	whoami    ->  Muestra mi nombre de usuario
	id        ->  Muestra la info extendida del usuario

	[filmico@localhost home]$ id
	uid=500(filmico) gid=500(filmico)   groups=500(filmico) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
    User ID          Primary Group ID   Other Group ID(name)

    groups		-> Muestra solo los grupos

    En estructuras jerarquicas, podemos dar los permisos r-x para que el usuario entre pero no borre el directorio raiz
    Luego a los directorios de adentro podemos darle rwx, entonces el usuario va a poder hacer lo que quiera pero ahi adentro.

    OJO CON UN TEMA: Si el directorio tiene permiso w para el grupo donde esta el usuario y existe un archivo que pertenece a otro usuario
    y no le da permisos ni al grupo ni a nadie mas, igual lo puedo borrar porque se hereda el permiso del directorio para e grupo

    - Mas info en el punto 32)

29) Cambiar de usuario

	su NombreUsuario   -> su significa Switch User    


30) sudo   

	admin / root / superUser   son todos equivalentes

	su usrName  -> switch user

	exist  		-> sale de la sesion del usuario al anterior
	               si se usa exit en la ultima sesion se cierra la consola

    sudo 		-> no hay que confundir con su ya que sudo significa: super user do

    - Supongamos que estoy en el grupo de administradores y quiero loguearme como otro usuario aunque no sepa su password
      Puedo ejecutar:

      sudo su usrName   -> (superUserDo SwitchUser UsrName)

      Deberia poder cambiar a usrName sin que me pida el usario de usrName

31) Usuarios

	- Los perfiles de usuario viven en /home/

	La info particular de cada usuario se almacena en /etc/ 
	Esta info contiene user name, login details, home directory y passord

	$ cat /etc/passwd   

	La lista es larguisima. 
	Podemos acotarla para buscar solo a filmico usando grep en el pipe de salida de la siguiente manera:

	$ cat /etc/passwd | grep filmico

	o simplemente

	$ grep "filmico" /etc/passwd

	- El resultado que nos devuelve es el siguiente:
	      
		filmico:x:500:500:filmico:/home/filmico:/bin/bash
	       1   :2: 3 : 4 :   5   :     6       :    7

	   1) usrName
	   2) generalmente es una x que indica que el password se guarda en un archivo oculto no aqui
	   3) usrID
	   4) groupID
	   5) usrFullName, telephone number, etc
	   6) home del usuario
	   7) Shell que usa el usuario cuando loguea. 
	      Es el ejecuta todos los comandos. En este caso se usa el shel bash

    - El verdadero password se guarda en

    	sudo cat /etc/shadow

    	De todas maneras el password esta encriptado!

    	La estructura es la siguiente:

    	pulse:!!:17682::::::
          1  : 2: 3   

      	1) usuario
      	2) password    * indica que no tiene seteado password

      		Linux no guarda los passwords, pero si guarda el resultado de hashear el password
      		Cuando ingresamos el password, lo hashea y compara su es igual a lo que tiene almacenado

      	   Si hay un password seteado, debemos observar los signos $

      	   filmico:$6$EYWTrQDS02XQWFFk$M2IKKSNIcmMbke3G/64PML7Ql40eDcTADppFNUl4QouwnBnq87oBK7IkcLg6erqLdfjZHj6w.fWs04b/hbgeP/:17682:0:99999:7:::
      	           $ $                $

           - El $6 indica el algoritmo usado para hashear el password. 6 Representa SHA.
       	   - El segundo signo $ contiene el SALT que se usara en el algoritmo.
       	     Esto previene que dos usuarios con el mismo password tengan el mismo resultado del algoritmo.
           - El ultimo $ indica el hash calculado del password ingresado

           - La info despues de los : indica cuanto dura la sesion, cada cuanto hay que cambiar el password, etc


    Para mas info, podemos ejecutar: $ man shadow

31) Agregar usuarios

	Lo mejor es agregar un usuario y meterlo en el grupo todo de una vez:

		$ sudo useradd -g "emily" -G "family,schoolmates" emily

	Con esto agregamos el usuario emily al grupo principal emily y a los grupos secundarios family y schoolmates.

	Otro Ejemplo creando emily y asignando grupo emily y grupo secundario gerardo 

		$ sudo groupadd emily
		$ sudo groupadd gerardo
		$ sudo useradd -g "emily" -G "gerardo" emily
		$ groups emily

			emily : emily gerardo


   Los grupos de los usuarios estan indicados en /etc/group:

	$ cat /etc/group | grep filmico
	filmico:x:500:

	Ahi se indica el grupo filmico que tiene un password y un ID 500

	Agregar usuarios: $ sudo adduser usrName

	a) Crea un directorio en el /home con el nombre del usuario
	b) Crea un nuevo grupo llamado igual que el usuario y lo asigna al grupo
	c) Crea la estructura basica en el /home de carpetas tipicas (download, documents, desktop, etc)

	Podemos verificar esto ejecutando:
	ls /home
	
	Chequeamos que exista el usuario
	--------------------------------
	$ sudo cat /etc/passwd | grep ger
		gerardo:x:501:501::/home/gerardo:/bin/bash

	Chequeamos que tenga password asociado
	--------------------------------------
	$ sudo cat /etc/shadow | grep gerardo
		gerardo:!!:17688:0:99999:7:::

	El doble !! indica que no tiene password seteado

	Chequeamos el grupo
	--------------------
	$ sudo cat /etc/group | grep ger
		gerardo:x:501:

	En el primer chequeo de usuario podemos ver que su grupo es el 501.
	En este ultimo chequeo observamos que existe un grupo 501 con el mismo nombre del usuario.

	Aca observamos que la x indica que el grupo gerardo tiene seteado un password default

	- adduser tiene muchos parametros que podemos usar al momento de la creacion de un usuario


32) Cambiar password de un usuario

    Lo puede hacer el root borrando el password anterior

    - El siguiente comando conviene ejecutarlo despues de bloquear la cuenta del usuario.
    - Luego de cambiar o borrar el password, podemos desbloquear la cuenta.

    passwd -d "gerardo"	   (Borra el password)

    passwd "gerardo"	   (Setea un nuevo password)

33) Agregar grupos

	sudo groupadd nombreGrp

	$ sudo groupadd migrupo

	Chequeamos que se haya agregado el grupo:
	cat /etc/group | grep  "mig"   

34) Agregar usuario a un grupo

	Al momento de creacion hacerlo asi:

	- Agrega emily al grupo friends como primario y a family y schoolmates como grupos secundarios 	

	sudo useradd -g "friends" -G "family,schoolmates" emily

	Si el usuario y el grupo ya estan creados, usar usermod

	sudo usermod -G "miGrupo" gerardo

	Para verificar la asignacion tipeamos:

	$ groups gerardo
	gerardo : gerardo miGrupo

35) Borrar usuario

	Por default, el borrado de un usuario no borra ni su home ni sus grupos

	Para borrar un usuario corremos:

	$ sudo userdel userName

	Para Borrar todo lo de un usuario corremos:

	$ sudo userdel -r userName	

36) Descripcion de grupos y usuarios	

	El comando lslogins tiene muchos parametros para entregar data de los usuarios

	$ lslogins -u

	  UID USER      PWD-LOCK PWD-DENY LAST-LOGIN GECOS
	    0 root                          15:53:06 root
	  500 filmico                       20:57:44 filmico
	  501 gerardo                       17:35:45 
	65534 nfsnobody                              Anonymous NFS User


37) Comando Tree

	- Por default no viene instalado con Centos o SL Linux. Corremos lo siguiente para instalarlo

	$ sudo yum install tree -y

38) Soft and Hard Links

	- Los Hard Links apuntan al mismo archivo en disco pero con otro nombre. (Su id en el sistema es distinto)
		Esto quiere decir que si borramos el archivo original, el hardlink seguira pudiendo acceder al contenido.
		De la misma manera, como los dos apuntan al mismo punto del disco, editar uno edita el otro.

	- Los Soft links funcionan como en windows. Si borramos el archivo, el soft link deja de poder acceder.

	Supongamos que tenemos un archivo llamado file1.txt

	- para crear un hard link hacemos

	$ ln file1.txt hardlink.txt

	si hacemos ls, devuelve la info donde solo por el tamaño observamos que son dos archivos iguales.

	Ahora, si usamos el comando $ ls -li, podemos observar que a la izquierda muestra el id (inode) del archivo y es el mismo

	 928153 -rw-rw-r--. 2 filmico filmico   19 Jun  7 19:32 archivo1.txt
	 928153 -rw-rw-r--. 2 filmico filmico   19 Jun  7 19:32 hardlink.txt

	- Ahora vamos a crear un soft link y volvemos a pedir el listado

	$ ln -s archivo1.txt softlink.txt
	$ ls -li

 928153 -rw-rw-r--. 2 filmico filmico   19 Jun  7 19:32 archivo1.txt
 928153 -rw-rw-r--. 2 filmico filmico   19 Jun  7 19:32 hardlink.txt
 928151 lrwxrwxrwx. 1 filmico filmico   12 Jun  7 19:36 softlink.txt -> archivo1.txt	

 	- Como podemos ver, el inode del soft link es distinto, lo que indica que si borramos el soft link no se borra el archivo original. A su vez la consola nos muestra a que archivo apunta el soft link.txt


39) Navegando con historial (pushd popd) 	

	- Como vimos antes, para imprimir el directorio de trabajo completo escribimos $ pwd

	$ pushd .          (Guarda el path del directorio actual en una Pila)
	$ dirs 			   (Lista la Pila)
    $ popd			   (Nos lleva al ultimo directorio guardado)

    Recordar que una vez que usamos popd, el directorio se borra de la pila.

40) Ver Contenido de Archivos (cat, tac, less, tail, head)

	cat, tail y head ya se vieron con anterioridad
	tac es inverso a cat y permite ir scroleando el archivo

	Less Is Better Than More!!!
	---------------------------
	less es muy similar a vim y permite escrolear un archivo y hacer busquedas
	more es igual a less pero no permite escrolear de arriba abajo en las busquedas

41) Crear archivos sin contenido

	$ touch es un comando interesante para actualizar el timeStamp de un archivo

	Si usamos touch seguido de un nombre de archivo que no existe, este archivo se crea.	

42) Reinstalar las utilidades

	- Siguiendo el tutorial, encontre que algunas utilidades como rm faltaban.
	Encontre que habia que re instalar el core utilities

	$ sudo yum reinstall coreutils

43) Crear y Borrar Archivos y Directorios	

	- En la consola no existe la papelera!

	$ mv	(move  mueve o renombra archivo. Si no especificamos path, solo renombra)
	$ rm    (remove - borra archivo)

	$ mkdir	  (crea directorios)
	$ rmdir   (borra directorios vacios)
	$ rm -rf  (borra directorios recursivamente hacia adentro y sus archivos de manera forzada)

	Hay dos parametros importantes de rm:

	-i (intereactive)
	-f (force)

	Un directorio no se puede borrar si tiene archivos. podemos borrar los archivos o borrar el directorio con rmdir -f

	-i se usa para pedir confirmacion antes del borrado

	- Para borrar todo el contenido de un directorio ejecutamos:

	$ rm *

	El siguiente comando borra recursivamente el directorio carpeta y todos sus archivos, preguntando interactivamente cada borrado.

	$ rm -rfi carpeta/

44) Modificar el look del Prompt

	- Usualmente el prompt luce asi:  usuario@ComputerName ubicacion
	Esto se guarda en la variable $PS1

	podemos chequearlo tipeando: $ echo $PS1

	[\u@\h \W]\$

	Para cambiarlo que es basicamente modificar la variable de entorno $PS1 tipeamos:

	$ PS1 = "\u@\h \$ "

45) Pipes

	Existen 3 streams siempre activos en un archivo

						 ID
		Standard input   0   (Usualmente el teclado)
		Standard Output  1   (Usualmente la consola)
		Standard Error   2   (Usualmente un archivo de log de errores)

	Podemos reconectar estos streams con los pipes

	Los simbolos > y < se usan para indicar si lo que sigue al comando es una entrada o una salida.
	< simbolo de entrada
	> simbolo de salida

	Ejemplos:

	$ do_something < input-file        (input-file es la entrada < de do_something)
	$ do_something > output-file       (output-file es la salida > de do_something)

	- Siguiendo la logica de los ID 0, 1, 2 podemos mapear el error a un archivo asi:

	$ do_something 2> error.log

	- Lo siguiente captura la salida y los errores en el mismo archivo. El %1 es reemplazado por el nombre del archivo all-output_file.txt

	$ do_something > all-output_file.txt 2>%1

46) Buscar Archivos (locate) 

	Es un comando relativamente nuevo en algunas distro de linux. Es super rapido pero su base de datos debe indexarse para ser certero. Solo los root pueden indexarla

	busca la palabra zip y de todo el listado lo que contenga la palabra bin

	$ locate zip | grep bin

	- Este listado se produce con una base de datos que usualmente linux actualiza todos los dias.
	  Para forzar la actualizacion corremos:

	$ sudo updatedb

	Para evitar esto pero en una version de busqueda mas lenta, podemos usar find

47) Buscar Arcivos (find)

	- A diferencia de locate, find no necesita de una base de datos. Esto hace que las busquedas sean mas lentas pero a su vez precisas.

	- Con el siguiente comando, podemos buscar todos los logs del directorio donde estamos parados

	$ sudo find . -name "*.log"

	- Con el siguiente comando buscamos desde el raiz,
	  todos los archivos cuya extension sea .log
	  de todo el listado, nos quedamos con los que tienen la palabra vmware
	  y por ultimo lo paginaos con less

	$ sudo find / -name "*.log" | grep vmware | less

	- Dentro de los parametros de find, hay uno muy interesante llamado type. 

	- type d busca directorios
	- type f busca ficheros

	$ find /usr -type d gcc   
	$ find /usr -type f gcc

	- Otro ejemplo. Buscar todos los directorios que se modificaron en la ultima hora

	$ sudo find / -type d -ctime 1 | less

	- Buscar archivos modificados hoy

	$ sudo find -type f -mtime 0

48) Borrar archivos por lotes con find

	- En el siguiente ejemplo, se muestra como find, busca archivos desde el root
	  con extension .log y de todo ese conjunto ejecuta la instruccion remove rm

	  los {} es donde se ubicaran los nombres de archivos separados por coma
	  y siempre se termina con ;

	$ find / -name "*.log" -exec rm {} ';'	

	- En vez de usar exec, podeos usar -ok para que linux nos pregunte en casa caso antes de proceder al borrado

	$ find / -name "*.log" -exec rm {} ';'	

49) Wildcards

	$ ls -al 	(lista todo (a) en modo lista (l))

 	? 		busca un caracter
 	*		busca uno o varios caracteres
 	[set]   busca individualmete los caracteres entre []
 	[!set]  lo opuesto de set

 	$ ls *.txt   		(Muestra todo los archivos con extension txt)
 	$ ls [tr]*.txt    	(Muestra todo los archivos que comiencen con tr, sigan con cualquier letra/s y que sean txt)

 	- Como en las expresioens regulares, si usamos letras entre - busca desde hasta la letra

 	$ ls [t-z]*.txt		(Muestra los archivos que comiencen con una letra comprendida entre t y z, que sigan con cualquier letra/s y que tengan extension txt)

50) Customizar parametros por default con el uso de alias y el archivo .bashrc

	En el siguiente ejemplo crearemos un alias para que al usar el comando ls se ejecute ls -l

	En linux, en nuestro perfil, existe algunos archivos ocultos de configuracion. Uno de ellos se llama .bachrc

	Lo podemos ver si ejecutamos $ ls -la ya que es un archivo oculto

	- El archivo .bachrc contiene datos de configuracion y definicion de alias de los comandos nativos

	Para editarlo hacemos:

	$ sudo vim ~/.bachrc   o  $ suvo vim .bashrc

	- Ahi podemos agregar esto:

	# User specific aliases and functions
	alias ls='ls -l --color=auto'	

	- Salimos presionando Esc, luego : y seguido wq que significa write quite

	Debemos reiniciar la consola para que el cambio surta efecto

51) Instalando software

	En Fedora, hay dos niveles de paquetes

	a) RPM (Bajo Nivel)
		- Detalle de desempaquetado de paquetes
		- Desempaquetado de paquetes individuales
		- Correr Scripts
		- Instalar el software correctamente

	b) yum (Alto Nivel)
		- Trabaja con grupo de paquetes
		- Se encarga de la descarga de los mismos
		- Revisa y resuelve dependencias

		YUM significa: Yellowdog Updater Modified. Es open source y es el package manager del RPM
		Las versiones nuevas de Fedora, reemplazaron YUM con el comando dnf que tiene poca compatibilidad con cosas viejas pero muchas ventajas nuevas y muy util para las herramientas del dia a dia

	- La mayoria de las veces, los usuarios usan yum que solo se encarga de llamar a RPM

	Nota: Puede pasar que un simple paquete, necesite de muchos paquetes grandes y que esto demore la bajada e instalacion.

	Operation RPM 
  	Install package 			 	rpm -i foo.rpm
  -	Install package dependencies 	yum install foo
	Remove package                  rpm -e foo.rpm
  -	Remove package dependencies     yum remove foo
	Update package                  rpm -U foo.rpm
  -	Update package dependencies     yum update foo 
  - Update entire system            yum update
  -	Show all installed packages     rpm -qa or yum list installed
	Get information on package      rpm -qil foo
	Show packages named foo         yum list "foo"
	Show all available packages     yum list apt-cache
 	What package is file part of?   rpm -qf file
  - Listar Paquetes instalados		yum list installed

	- Ejemplo de instalacion de paquete lynx que es un navegador web por consola
	$ sudo yum search lynx    (Con eso obtenemos la data de librerias y del paquete que vamos a bajar)
	$ sudo yum install lynx   (Instalamos el paquete)
	$ sudo yum info lynx      (Obtenemos info del paquete)
	$ sudo yum remove lynx    (Quitamos el paquete)

52) Averiguar version del kernel instalada

	$ sudo uname -r

		2.6.32-696.30.1.el6.x86_64   (Es comparable con un Fedora 12 o 13 que usan kernel 2.6.3x)
		https://en.wikipedia.org/wiki/Fedora_version_history

53) Instalar VLC

	Instrucciones detalladas  https://www.videolan.org/vlc/download-redhat.html

	1) Instalar RPM Fusion (Free and NonFree)  https://rpmfusion.org/Configuration/

		$ sudo yum localinstall --nogpgcheck https://download1.rpmfusion.org/free/el/rpmfusion-free-release-6.noarch.rpm https://download1.rpmfusion.org/nonfree/el/rpmfusion-nonfree-release-6.noarch.rpm	

	2) Instalar Extra Package for Enterprise Linux  (https://fedoraproject.org/wiki/EPEL)

		$ sudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm		
	3) Instalar VLC
		
		$ sudo yum install vlc

54) Documentacion

	- En el modo grafico podemos ir a System -> Help donde encontraremos toda la ayuda incluidos los manuales.

	- Man (Podemos repasar como se usa en el punto 0 de este archivo)

	Man en la web http://man7.org/linux/man-pages/

	- https://www.gentoo.org/support/documentation/

	- GNU Info System (Es un sistema anterior a la WWW que tiene documentos enganchados)
	  Esto permite browsear un help desde la consola

	  $ El comando mas importante es info

	  $ Info 		(Tipeado solo y sin parametros, nos muestra el indice de todos los comandos del sistema)

	  $ info ls     (Se usa up page, down page, flechitas, h para help y q para salir)

	  - Comandos dentro de info

	  h 		Muestra el help de info
	  Ctrl+s 	Search - Hace busquedas. Ctrl+s de vuelta sigue avanzando en la busqueda. Para salir Ctrl+g
	  q 		Sale del programita
	  *         Cuando vemos un asterisco significa que podemos entrar en ese link con enter. 
	  l         Volver atras
      q         sale de info

55) Crear archivo ejecutable tipo Batch

	a) Crear el archivo con vim
		$ vim archEjecutable

	b) Agregar la ruta al bash al principio del archivo

		#!/bin/bash
	
	c) Indicar algun comando a ejecutar. Por ejemplo la calculadora de gnome
		/usr/bin/gnome-calculator

    d) Cambiar el modo del archivo a ejecutable

    	$ chmod +x archEjecutable

	e) Para ejecutar correr:

	   ./archEjecutable

56) Process

	- Los procesos pueden correr en el background. Esto libera a la consola de ese proceso.
		
	Tipos de procesos:

	a) Interactive: Normalmente los lanza el usuario desde la consola o desde la interfaz grafica. Ej: bash, firefox

	b) Batch Processes: Procesos automaticos que se suelen lanzar desde la consola y que arrancan de manera desconectada de la misma consola. EJ: updatedb

	c) Deamons: Procesos del sistema operativo que corren incluso en el arranque del sistema y que estan a la espera de la solicitud de ejecucion de una accion, por parte del usuario. Ej: httpd, xinetd, sshd

	d) Threads: Tareas que se lanzan en paralelo desde un proceso. Estas tareas pueden ir terminando por separado y no cerrar el proceso que las lanzo. EJ: firefox, gnome-terminal-server

	e) Kernel Threads: Son tareas del kernel que el usuario final no lanza ni termina. Realizan tareas como mover los threads de un procesador al otro, asegurarse que las operaciones de lectura/escritura del disco rigido hayan sigo completadas, etc.  Ej: kthreadd, migration, ksoftirqd


	- En linux existe una funcion central que se llama scheduler y que se encarga de asignar el tiempo permitido de ejecucion para cada proceso. Estos permisos de ejecucion, se colocan en una pila donde van corriendo por de manera secuencial. En el caso de un equipo multiprocesador, existe una pila de ejecucion por cada nucleo.
	Tambien existe una pila de espera para los procesos que requieren de que otros terminen o de la intervencion del usuario como por ejemplo, una respuesta ingresada por teclado.

    - Procesos Zombies
      Los procesos zombies, son un estado de un proceso hijo que ha terminado y cuyo padre no pregunta si ese hijo ha terminado. De esta manera el padre, queda encendido indefinidamente y sin hacer nada. 

  	- ID  (Linux asigna un ID a cada proceso)

  	  PID  -> significa Process ID
  	  PPID -> significa Parent Process ID
  	  TID  -> significa Thread ID. 

  	  Todos los threads que pertenecen a un mismo proceso, tienen un TID diferente pero un mismo PID

  	- Los procesos se pueden terminar con el siguiente comando:
  	  ---------------------------------------------------------

  	$ ps     (Lista los procesos)

		   PID TTY          TIME CMD
		  3402 pts/0    00:00:00 bash
		  3912 pts/0    00:00:00 ps  	

  	Supomgamos que queremos terminar ps cuyo PID es 3912

  	$ kill -9 3912    (El -9 indica la manera en que matamos el proceso)

  	$ ps aux 	(Lista todos los procesos auxiliares)
  	$ ps aux | grep filmico    (lista los procesos y filtra de los resultados, solo los que dicen filmico en alguna parte del renglon)

  	- Los usuarios y los grupos tienen los siguientes ID
  	  ---------------------------------------------------

  	RUID	Real User ID who start the process
  	EUID	Efective User ID of the User who alow this user to run the process. 
  	RGID 	Real Group ID of the user
  	EGID	Access right of the group

  	- Prioridad de los procesos
  	  -------------------------

  	Los procesos tienen prioridad de ejecucion. 

  	La prioridad mas alta es -20
  	La prioridad mas baja es  19


  	- Comando top
  	  -----------
  	  El comando top es una especie de task manager de windows
  	  Muestra un listado con los PID, usuarios y cada proceso que esta corriendo

      Existe un comando llamado htop que es todavia mas parecido al task manager del windows
      Funciona en consola y lo podemos instalar con:

      $ sudo yum install htop

    ps 

    Ver el archivo de los tutoriales: 
    C:\Linux Training\Tutoriales\03_Procesos\URL y comandos.txt

57) Tareas Programadas  (at - cron -sleep)
	
	AT
	**

	at permite ejecutar una sentencia en un momento especifico.

	$ at now + 2 days cat file1.txt    (Presionar Ctrl+D para salir

	CRON
	****

	- Existen las tablas de cron a nivel de usuario y a nivel de sistema
	Las mismas se ubican en  /etc/crontab

	El comando para entrara a editar las tareas programadas es el siguiente:

	$ crontab -e

	Los valores son los siguientes:

	Field	Description		Values
	MIN		Minutes			0 to 59
	HOUR	Hour field		0 to 23
	DOM		Day of Month	1-31
	MON		Month field		1-12
	DOW		Day Of Week	0-6 (0 = Sunday)
	CMD	Command	Any command to be executed	

	- Cada linea es un job que hay que correr y el mismo tiene que tener una serie de atributos
	  A continuacion, se muestra una tarea que se tiene que ejecutar, cada dia, a cada hora, de cada mes de cada año
	* * * * * /usr/local/bin/execute/this/script.sh

	  A continuacion, se muestra una tarea que se tiene que ejecutar 08:30 el 10/06 no importando si es lunes, martes, miercoles, etc
	30 08 10 06 * /home/sysadmin/full-backup

	SLEEP
	*****
	A diferencia de "at", que lanza la ejecucion en un momento, sleep permanece en espera para ejecutar hasta que una señal o un tiempo determinado se cumpla.

	Syntax: sleep NUMBER[SUFFIX]...

	where SUFFIX may be:
                1.   s for seconds (the default)
                2.   m for minutes
                3.   h for hours
                4.   d for days.



58) Cambiar nombre al PC

	Este texto, se encuentra repetido en el archivo Networking.txt

	Fuente: http://www.labtestproject.com/using_linux/permanently_change_hostname_on_fedora

	Se puede cambiar el nombre del host durante la sesion de consola o de manera permanente

	- Durante la sesion
		$ hostname subDomain.domain.com     (Version con subdominio y dominio)
		$ hostname myStation                (Version solo con nombre)

	- Permanente
		Se debe editar el archivo /etc/sysconfig/network

		1) Primero hacemos una copia
		$ sudo cp -pr /etc/sysconfig/network /etc/sysconfig/network.bak

		2) Editamos el archivo
		$ sudo vim /etc/sysconfig/network

		NETWORKING=yes
		HOSTNAME=localhost.localdomain        (Cambiamos este valor por el nuevo nombre Ej. Server)
		NTPSERVERARGS=iburst

		3) Verificamos que el cambio surtio efecto y reiniciamos

		$ sudo cat /etc/sysconfig/network

		Nota: No se debe editar el archivo hosts como indica en la mayoria de los links	
	                
59) Comando Cut

	Cut, nos permite buscar y quitar columnas de un resultado

	El siguiente ejemplo, lista los usuarios del sistema, cortando las columnas por el :
	y quedandose con las columnas 1 y 3

	$ sudo cat /etc/passwd |grep /home* |cut -d ':' -f 1,3

	El siguiente ejemplo, lista los usaurios de Samba Network

	$ sudo cat /etc/passwd |grep */bin/bash* |grep *[1][0-9][0-9][0-9]* |cut -d ':' -f 1


	Fuente: https://www.computerhope.com/unix/ucut.htm
			https://www.thegeekstuff.com/2013/06/cut-command-examples/



60) Administracion de discos

	Para preparar un disco o dispositivo para grabar en el, tenemos que hacer los siguientes pasos

	1) Particionar el Espacio 
	2) Crear un File System (Formatearlo)
	3) Montarlo y agregarlo a fstab para que lo monte al inicio

	Los siguientes Paquetes se necesitan para poder leer y escribir en particiones NTFS

	ntfsprogs y ntfs-3g   (ntfs-3g es una dependencia de ntfsprogs)

	Como MBR tiene un tope de 2TB se paso a usar GPT
	GPT = Guid Partition Table
	GPT es parte de UEFI (Unified Extensible Framework Interface)

	GPT soporta hasta 128 particiones y 9.4 Zetabytes

	Soft utiles para trabajar con particiones:
	Tradicionalmente se usaba fdisk pero no se puede usar con particiones GPT salvo que sea una version nueva. 
	Alternativamente se puede usar parted, gdisk o gparted que es la GUI de parted

	1) Particionar el Espacio 

	PARTED
	------

	Para remover las particiones del pendrive, debemos verificar que el dispositivo este desmontado

	$ sudo cat /etc/mtab

	Si vemos que existe un sdb1 o un sdb procedemos a desmontarlo ejecutando

	$ sudo umount sdb1
	$ sudo umount sdb

	Por default el comando "parted" abre tomando el disco de sistema como seleccionado.
	Debemos cambiar a otro disco usando select como se indica a continuacion.

	$ sudo parted
	- help 					lista los comandos
	- print list 			lista todos los dispositivos
	- select /dev/sdb       Selecciona el disco 2 sdb
	- print                 Ejecutandolo solo nos muestra info del disco seleccionado

	(parted) select /dev/sdb                                                  
	Using /dev/sdb

	(parted) print                                                            
	Model: ADATA USB Flash Drive (scsi)
	Disk /dev/sdb: 15.5GB
	Sector size (logical/physical): 512B/512B
	Partition Table: gpt

	Number  Start   End     Size    File system  Name                  Flags
	 1      1049kB  15.5GB  15.5GB  ntfs         Basic data partition

	- Tambien podemos ejecutar help seguido del comando y ver mas ayuda
	- help mkpart

	Creando Particion Tipo Ext2
	---------------------------
	(parted) mkpart
	Partition name?  []? Nombre
	File system type?  [ext2]?
	Start? 1                         Dejamos del 0 al 1 mb libre para el boot sector, etc
	End? 512


	(parted) print                                                            
	Model: ADATA USB Flash Drive (scsi)
	Disk /dev/sdb: 15.5GB
	Sector size (logical/physical): 512B/512B
	Partition Table: gpt

	Number  Start   End     Size    File system  Name                  Flags
	 2      1048kB  1049kB  512B                 Datos
	 1      1049kB  15.5GB  15.5GB  ntfs         Basic data partition

	rm 2       borra la particion 2
	rm 1       borra la particion 1

	La sintaxis de creacion de la particion es la siguiente:

	mkpart PART-TYPE [FS-TYPE] START END 
 
 	Ejecutamos:

 	mkpart primary ext4 2048s 100%   (Desde el cilindro 2048 que es el inicio hasta el 100% del pendrive)
	mkpart primary ext4 0% 100%      (Esto tambien deberia funcionar par dimensionar al 100%)

	Ejemplo:

	(parted) mkpart primary ext4 0% 50%
	(parted) print
	Model: ADATA USB Flash Drive (scsi)
	Disk /dev/sdb: 15.5GB
	Sector size (logical/physical): 512B/512B
	Partition Table: gpt

	Number  Start   End     Size    File system  Name     Flags
	 1      1049kB  7759MB  7758MB  ntfs         primary             Queda la particion de 7.7 GB

                                                     
	(parted) mkpart secondary ext4 50% 100%                                    
	(parted) print
	Model: ADATA USB Flash Drive (scsi)
	Disk /dev/sdb: 15.5GB
	Sector size (logical/physical): 512B/512B
	Partition Table: gpt

	Number  Start   End     Size    File system  Name       Flags
	 1      1049kB  7759MB  7758MB  ntfs         primary
	 2      7759MB  15.5GB  7758MB               secondary

	Por Default, las expresiones sin sigla son MegaBytes

	parted) mkpart                                                           
	Partition name?  []? Test                                                 
	File system type?  [ext2]?                                                
	Start? 1
	End? 512	 								parted entiende 512 como 512 Megabytes
	(parted) print                                                            
	Model: ADATA USB Flash Drive (scsi)
	Disk /dev/sdb: 15.5GB
	Sector size (logical/physical): 512B/512B
	Partition Table: gpt

	Number  Start   End    Size   File system  Name  Flags
	 1      1049kB  512MB  511MB  ntfs         Test

	2) Crear un File System (Formatearlo)

	Una ves que concluimos con la creacion de las particiones, procedemos a Crear el File System o como windows lo llama, formatear las unidades. 
	Esto nos permite designar el tipo de archivos (Fat32, NTFS, Ext2,3,4, etc)

	El comando mkfs nos permite crear el FS pero debemos indicar que programa especifico queremos correr con la notacion -t

      fs(5),  badblocks(8),  fsck(8),  mkdosfs(8),  mke2fs(8),  mkfs.bfs(8),  mkfs.ext2(8),  mkfs.ext3(8),  mkfs.ext4(8),  mkfs.minix(8),  mkfs.msdos(8),  mkfs.vfat(8),   mkfs.xfs(8),
       mkfs.xiafs(8)	

	mkfs.vfat 
		Es el Fat32 de Windows y el que debemos usar para compartir entre win y Linux)
	
	mkfs.ext2 
		Es la version de Linux del Fat32. No es compatible con win y no es journaled. Recomendable para la particion boot en discos mecanicos ya que tiene que leer y escribir menos.
		La contra de este sistema es que si el equipo se cuelga, al bootear se tiene que chequear el disco entero por falta de journaling.
	
	mkfs.ext3 
		Es una version mejorada y ya cuenta con journaling. Ext3 o NTFS, si bien es un poquito mas pesado en lecturas y escrituras, permite recuperarse mucho mas rapido de un crash ya que no se tiene que chequear track a track del disco para corregir los problemas.

	mkfs.ext4 
		Es la version mas recomendada. Cuenta con journaling y muchas optimizaciones que incluso previenen la defragmentacion.

	Para ver un manual especifico, ejecutamos:

	$ man mkfs.vfat    

	Ver el listado de particiones y discos disponibles
	$ sudo fdisk -l |less     o       $ sudo lsblk

	Crear el FS en sdb1 y sdb2:
	$ sudo mkfs -t ext2 -m 0 -L /boot /dev/sdb1
	$ sudo mkfs -t ext4 -m 0 -L /usbdrive /dev/sdb2            
		-t para el tipo 
		-m 0 para que no reserve espacio para el root
		-L para ponerle una etiqueta y que se pueda montar por nombre. Ojo que la L va en Mayuscula
		Al final se tiene que especificar la unidad

	Tener en cuenta al momento de indicar este comando, la ruta a la particion al final ya que podemos llegar por error a indicar por ejemplo sdb en vez de sdb1 y de esta manera estariamos volando todas las particiones para instalar un filesystem en todo el dispositivo y no es lo que queremos.

	$ lsblk

	NAME                        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
	sda                           8:0    0   20G  0 disk 
	├─sda1                        8:1    0  500M  0 part /boot
	└─sda2                        8:2    0 19.5G  0 part 
	  ├─VolGroup-lv_root (dm-0) 253:0    0 17.5G  0 lvm  /
	  └─VolGroup-lv_swap (dm-1) 253:1    0    2G  0 lvm  [SWAP]
	sr0                          11:0    1  5.8G  0 rom  /media/"Scientific 6.8 x86_64 DVD-DL"
	sdb                           8:16   1 14.5G  0 disk 
	├─sdb1                        8:17   1  190M  0 part 
	└─sdb2                        8:18   1 14.3G  0 part	




	3) Montarlo y agregarlo a fstab para que lo monte al inicio 

	En linux y a diferencia de windows, debemos crear una carpeta para montar alli el contenido de una unidad. En el caso del Pendrive que acabamos de poner el file system en el punto 2, crearemos una carpeta en el root llamada /keydrive.

	$ sudo mkdir /keydrive
	$ ls -l /
	drwxr-xr-x.   2 root    root   4096 Jun 20 12:48 keydrive

	Recordar que debemos cambiar los permisos para que todos los usuarios puedan acceder!

	El comando "mount" nos muestra todos los dispositivos montados

	$ sudo mount -l

	Por lo general los dispositivos aparecen ya montados en el directorio /dev/ como sdb2, sdb3, etc

	Para verificar los dispositivos que ve el equipo y que podemos montar, podemos usar lsblk

	Para montar el dispositivo ejecutamos:

	$ sudo mount /dev/sdb2 /keydrive/

	El siguiente aso es igual pero indica el tipo de particion que estamos montando

	$ sudo mount -t ext4 /dev/sdb2 /keydrive/     (La info del tipo la obtenemos con mount -l)

	Montando de manera permanente un dispositivo
	--------------------------------------------
	
	Para montar unidades de manera que esten disponibles al momento del booteo, debemos editar el archivo /etc/fstab

	fstab a diferencia de la consola, montas los dispositivos con otra sintaxis y necesita de un identificador del disco.

	Existen 3 Maneras de referenciar al dispositivo y se obtienen con el comando block id blkid
	El resultado muestra el path de dev, el labely el UUID además del tipo

	$ sudo blkid /dev/sdb2
	/dev/sdb2: LABEL="/usbdrive" UUID="2a445f41-5404-46b5-963e-ffba05e807d8" TYPE="ext4" 

	La ventaja de usar el label o el UUID es que si las letras se corren, por enchufar o desenchufar discos, podemos estar montando el disco equivocado. En cambio, referenciando por LABEL o UUID, no hay manera de equivocarse. Lo mas recomendable es usar el UUID.

	Ahora que tenemos identificado el dispositivo, procedemos a editar fstab agregando el mount al final de todo:

	$ sudo vim /etc/fstab

	UUID=2a445f41-5404-46b5-963e-ffba05e807d8    /keydrive        ext4  defaults       0 2


	La syntaxis es la siguiente:
	Numero UUID         Lugar de montaje     Tipo      default options       0               2
	                                                   (rw user acces)     dump          orden de chequeo si el sistema hace un crash

    Verificamos que el dispositivo no este montado y testeamos si fstab lo levanta

    $ sudo mount
    $ sudo mount -a     (-a lee fstab y monta todo lo que indica)

    Si queremos hacer cambios temporales de unidades ya montadas por fstab, no hace falta ni editar el archivo y desmontar la unidad.
    Podemos usar el comando mount para cambiar el comportamiento on-the-fly

    Cambiamos el dispositivo a read only:

    $ sudo mount -o remount,ro /dev/sdb2 /keydrive
	
    Por ultimo, mount tiene parametros muy utiles para montar dispositivos de red.
    $ man mount muestra el extenso manual de este comando.

    







	Agregados al apartado de Administracion de Dispositivos
	-------------------------------------------------------

	1) Mostrar Dispositivos

		$ sudo fdisk -l |less

		Esto arroja un listado que comienza con /dev/sda. sda = Serial Ata Disk A o primer disco

		Disk /dev/sda: 21.5 GB, 21474836480 bytes

		Luego vemos abajo las particiones de ese disco, nombradas como sda1, sda2, etc

		   Device Boot      Start         End      Blocks   Id  System
		/dev/sda1   *           1          64      512000   83  Linux
		/dev/sda2              64        2611    20458496   8e  Linux LVM

		Como Observamos en el listado que sigue, la particion sda2 con sistema Linux LVM del renglon de arriba, se conforma con dos divisiones logicas de 18GB y 2GB correspondientemente.

		Disk /dev/mapper/VolGroup-lv_root: 18.8 GB, 18798870528 bytes
		Disk /dev/mapper/VolGroup-lv_swap: 2147 MB, 2147483648 bytes

	2) Ver Particiones. Ojo, no se muestran todas las del disco. Usar Gparted!
	$ df -h

	C:\Linux Training\Udemy Linux Administration Bootcamp\Linux Administration Bootcamp Go from Beginner to Advanced\06 Disk Management

	C:\Linux Training\Tutoriales\05_Partitions

	3) Ver Dispositivos y Particiones (The Great Way)

		El comando lsblk presente en la mayoria de los linux, nos muestra en consola el diagrama completo de dispositivos.

		$ sudo lsblk

		NAME                        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
		sda                           8:0    0   20G  0 disk 
		├─sda1                        8:1    0  500M  0 part /boot
		└─sda2                        8:2    0 19.5G  0 part 
		  ├─VolGroup-lv_root (dm-0) 253:0    0 17.5G  0 lvm  /
		  └─VolGroup-lv_swap (dm-1) 253:1    0    2G  0 lvm  [SWAP]
		sr0                          11:0    1  5.8G  0 rom  /media/"Scientific 6.8 x86_64 DVD-DL"
		sdb                           8:16   1 14.5G  0 disk 
		├─sdb1                        8:17   1  190M  0 part 
		└─sdb2                        8:18   1 14.3G  0 part		



61) Syncronizacion  (rsync - Backup)

	Para copiar se puede usar el comando "cp", pero existe un comando que es mas robusto llamado "rsync"

	rsync, compara y solo copia las diferencias de archivos y directorios, haciendo que la copia o backup sean super rapidos

	$ rsync -r project-X archive-machine:archives/project-X

	rsync puede ser un comando peligroso si no se especifican correctamente los path. Conviene usar el parametro -dry-run para verificar primero la operatoria antes de ejecutarla definitivamente

	$ rsync -dry-run sourcefile destinationfile

62) Compresion Descompresion de Datos

	62.1) gzip		The most frequently used Linux compression utility
	62.2) bzip2		Produces files significantly smaller than those produced by gzip
	62.3) xz		The most space-efficient compression utility used in Linux
	63.4) zip		Is often required to examine and decompress archives from other operating systems
	63.5) tar 		Existe una utilidad llamada tar que agrupa varios archivos en uno solo y que a su vez lo comprime utilizando alguno de los algoritmos indicados arriba

    Ejemplos de uso:

    62.1) gzip

    	gzip is the most often used Linux compression utility. 
    	It compresses very well and is very fast. 
    	The following table provides some usage examples:

		gzip *					Compresses all files in the current directory; each file is compressed and renamed with a .gz extension.
		gzip -r projectX		Compresses all files in the projectX directory, along with all files in all of the directories under projectX.
		gunzip foo				De-compresses foo found in the file foo.gz. Under the hood, the gunzip command is actually the same as gzip –d.

	62.2) bzip2

		bzip2 has a syntax that is similar to gzip but it uses a different compression algorithm and produces significantly smaller files, at the price of taking a longer time to do its work. 
		Thus, it is more likely to be used to compress larger files.

		bzip2 *					Compresses all of the files in the current directory and replaces each file with a file renamed with a .bz2 extension.
		bunzip2 *.bz2			Decompresses all of the files with an extension of .bz2 in the current directory. Under the hood, bunzip2 is the same as calling bzip2 -d.		

	62.3) xz

		xz is the most space efficient compression utility used in Linux and is now used by www.kernel.org to store archives of the Linux kernel. 
		Once again, it trades a slower compression speed for an even higher compression ratio.

		$ xz *									Compresses all of the files in the current directory and replaces each file with one with a .xz extension.
		xz foo									Compresses the file foo into foo.xz using the default compression level (-6), and removes foo if compression succeeds.
		xz -dk bar.xz							Decompresses bar.xz into bar and does not remove bar.xz even if decompression is successful.
		xz -dcf a.txt b.txt.xz > abcd.txt		Decompresses a mix of compressed and uncompressed files to standard output, using a single command.
		$ xz -d *.xz							Decompresses the files compressed using xz.		

	62.4) zip

		The zip program is not often used to compress files in Linux, but is often required to examine and decompress archives from other operating systems. 
		It is only used in Linux when you get a zipped file from a Windows user. It is a legacy program.

		zip backup *					Compresses all files in the current directory and places them in the file backup.zip.
		zip -r backup.zip ~				Archives your login directory (~) and all files and directories under it in the file backup.zip.
		unzip backup.zip				Extracts all files in the file backup.zip and places them in the current directory.		

	62.5) tar

		Historically, tar stood for "tape archive" and was used to archive files to a magnetic tape. It allows you to create or extract files from an archive file, often called a tarball. 
		At the same time, you can optionally compress while creating the archive, and decompress while extracting its contents.

		$ tar xvf mydir.tar					Extract all the files in mydir.tar into the mydir directory
		$ tar zcvf mydir.tar.gz mydir		Create the archive and compress with gzip
		$ tar jcvf mydir.tar.bz2 mydir		Create the archive and compress with bz2
		$ tar Jcvf mydir.tar.xz mydir		Create the archive and compress with xz
		$ tar xvf mydir.tar.gz				Extract all the files in mydir.tar.gz into the mydir directory. Note you do not have to tell tar it is in gzip format.		